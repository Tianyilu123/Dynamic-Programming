class Solution {
    public int maxVacationDays(int[][] flights, int[][] days) {
        
        if(days == null || days.length == 0 || days[0] == null || days[0].length == 0)
            throw new IllegalArgumentException();
            
        if(flights == null || flights.length == 0 || flights[0] == null || flights[0].length == 0) {
            int sum = 0;
            for(int i=0; i<days[0].length; i++) {
                sum += days[0][i];
            }
            return sum;
        }
        
        int cityLen = flights.length;
        int weekLen = days[0].length;
        
        int[] dp = new int[cityLen];
        Arrays.fill(dp, Integer.MIN_VALUE);
        dp[0] = 0;
        
        for(int i=0; i<weekLen; i++) {
            int rollDp[] = new int[cityLen];
            Arrays.fill(rollDp, Integer.MIN_VALUE);
            
            for(int j=0; j<cityLen; j++) {
                for(int k=0; k<cityLen; k++) {
                if(k==j || flights[k][j] == 1) {
                    rollDp[j] = Math.max(rollDp[j], dp[k]+days[j][i]);
                }
            }
        }
        dp = rollDp;
    }
    
    int max = 0;
    for(int j=0; j<cityLen; j++) {
        max = Math.max(max, dp[j]);
    }
    return max;
}
}

// time: O(k*N*N)
// space: O(n)



// method 2:

class Solution {
    int max=0, N=0, K=0;
    
    public int maxVacationDays(int[][] flights, int[][] days) {
        N = flights.length;
        K = days[0].length;
        dfs(flights, days, 0, 0, 0);
        
        return max;
    }
    
    // curr : current city
    private void dfs(int[][] f, int[][] d, int curr, int week, int sum) {
        if(week == K) {
            max = Math.max(max, sum);
            return;
        }
        
        for(int dest=0; dest<N; dest++) {
            if(curr == dest || f[curr][dest] == 1) {
                dfs(f, d, dest, week+1, sum + d[dest][week]);
            }
        }
    }
}
